{
  "version": "20070901",
  "title": "알라딘 상품정보 - 모던 자바스크립트 Deep Dive",
  "link": "https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=251552545",
  "pubDate": "Thu, 12 May 2022 17:37:54 GMT",
  "imageUrl": "http://www.aladin.co.kr/ucl_editor/img_secur/header/2010/logo.jpg",
  "totalResults": 1,
  "startIndex": 1,
  "itemsPerPage": 1,
  "query": "isbn13=9791158392239",
  "searchCategoryId": 0,
  "searchCategoryName": "",
  "item": [
    {
      "title": "모던 자바스크립트 Deep Dive - 자바스크립트의 기본 개념과 동작 원리",
      "link": "http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=251552545&amp;copyPaper=1&amp;ttbkey=ttbchltjddnrwkd1525001&amp;start=api",
      "author": "이웅모 지음",
      "pubDate": "2020-09-24",
      "description": "자바스크립트를 둘러싼 기본 개념을 정확하고 구체적으로 설명하고, 자바스크립트 코드의 동작 원리를 집요하게 파헤친다. 작성한 코드가 컴퓨터 내부에서 어떻게 동작할 것인지 예측하고, 명확히 설명할 수 있도록 돕는다.",
      "creator": "aladin",
      "isbn": "K282633473",
      "isbn13": "9791158392239",
      "itemId": 251552545,
      "priceSales": 40500,
      "priceStandard": 45000,
      "stockStatus": "",
      "mileage": 2250,
      "cover": "https://image.aladin.co.kr/product/25155/25/cover/k282633473_1.jpg",
      "categoryId": 6355,
      "categoryName": "국내도서>컴퓨터/모바일>웹디자인/홈페이지>HTML/JavaScript",
      "publisher": "위키북스",
      "customerReviewRank": 10,
      "bookinfo": {
        "subTitle": "자바스크립트의 기본 개념과 동작 원리",
        "originalTitle": "",
        "itemPage": 956,
        "toc": "<p>▣ 01장: 프로그래밍<BR>\n1.1 프로그래밍이란?\t<BR>\n1.2 프로그래밍 언어\t<BR>\n1.3 구문과 의미\t<BR>\n<BR>\n▣ 02장: 자바스크립트란?<BR>\n2.1 자바스크립트의 탄생\t<BR>\n2.2 자바스크립트의 표준화\t<BR>\n2.3 자바스크립트 성장의 역사\t<BR>\n____2.3.1 Ajax\t<BR>\n____2.3.2 jQuery\t<BR>\n____2.3.3 V8 자바스크립트 엔진\t<BR>\n____2.3.4 Node.js\t<BR>\n____2.3.5 SPA 프레임워크\t<BR>\n2.4 자바스크립트와 ECMAScript\t<BR>\n2.5 자바스크립트의 특징\t<BR>\n2.6 ES6 브라우저 지원 현황\t<BR>\n<BR>\n▣ 03장: 자바스크립트 개발 환경과 실행 방법<BR>\n3.1 자바스크립트 실행 환경\t<BR>\n3.2 웹 브라우저\t<BR>\n____3.2.1 개발자 도구\t<BR>\n____3.2.2 콘솔\t<BR>\n____3.2.3 브라우저에서 자바스크립트 실행\t<BR>\n____3.2.4 디버깅\t<BR>\n3.3 Node.js\t<BR>\n____3.3.1 Node.js와 npm 소개\t<BR>\n____3.3.2 Node.js 설치\t<BR>\n____3.3.3 Node.js REPL\t<BR>\n3.4 비주얼 스튜디오 코드\t<BR>\n____3.4.1 비주얼 스튜디오 코드 설치\t<BR>\n____3.4.2 내장 터미널\t<BR>\n____3.4.3 Code Runner 확장 플러그인\t<BR>\n____3.4.4 Live Server 확장 플러그인\t<BR>\n<BR>\n▣ 04장: 변수<BR>\n4.1 변수란 무엇인가? 왜 필요한가?\t<BR>\n4.2 식별자\t<BR>\n4.3 변수 선언\t<BR>\n4.4 변수 선언의 실행 시점과 변수 호이스팅\t<BR>\n4.5 값의 할당\t<BR>\n4.6 값의 재할당\t<BR>\n4.7 식별자 네이밍 규칙\t<BR>\n<BR>\n▣ 05장: 표현식과 문<BR>\n5.1 값\t<BR>\n5.2 리터럴\t<BR>\n5.3 표현식\t<BR>\n5.4 문\t<BR>\n5.5 세미콜론과 세미콜론 자동 삽입 기능\t<BR>\n5.6 표현식인 문과 표현식이 아닌 문\t<BR>\n<BR>\n▣ 06장: 데이터 타입<BR>\n6.1 숫자 타입\t<BR>\n6.2 문자열 타입\t<BR>\n6.3 템플릿 리터럴\t<BR>\n____6.3.1 멀티라인 문자열\t<BR>\n____6.3.2 표현식 삽입\t<BR>\n6.4 불리언 타입\t<BR>\n6.5 undefined 타입\t<BR>\n6.6 null 타입\t<BR>\n6.7 심벌 타입\t<BR>\n6.8 객체 타입\t<BR>\n6.9 데이터 타입의 필요성\t<BR>\n____6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조\t<BR>\n____6.9.2 데이터 타입에 의한 값의 해석\t<BR>\n6.10 동적 타이핑\t<BR>\n____6.10.1 동적 타입 언어와 정적 타입 언어\t<BR>\n____6.10.2 동적 타입 언어와 변수 \t<BR>\n<BR>\n▣ 07장: 연산자<BR>\n7.1 산술 연산자\t<BR>\n____7.1.1 이항 산술 연산자\t<BR>\n____7.1.2 단항 산술 연산자\t<BR>\n____7.1.3 문자열 연결 연산자\t<BR>\n7.2 할당 연산자\t<BR>\n7.3 비교 연산자\t<BR>\n____7.3.1 동등/일치 비교 연산자\t<BR>\n____7.3.2 대소 관계 비교 연산자\t<BR>\n7.4 삼항 조건 연산자\t<BR>\n7.5 논리 연산자\t<BR>\n7.6 쉼표 연산자\t<BR>\n7.7 그룹 연산자\t<BR>\n7.8 typeof 연산자\t<BR>\n7.9 지수 연산자\t<BR>\n7.10 그 외의 연산자\t<BR>\n7.11 연산자의 부수 효과\t<BR>\n7.12 연산자 우선순위\t<BR>\n7.13 연산자 결합 순서\t<BR>\n<BR>\n▣ 08장: 제어문<BR>\n8.1 블록문\t<BR>\n8.2 조건문\t<BR>\n____8.2.1 if...else 문\t<BR>\n____8.2.2 switch 문\t<BR>\n8.3 반복문\t<BR>\n____8.3.1 for 문\t<BR>\n____8.3.2 while 문\t<BR>\n____8.3.3 do...while 문\t<BR>\n8.4 break 문\t<BR>\n8.5 continue 문<BR>\n<BR>\n▣ 09장: 타입 변환과 단축 평가\t<BR>\n9.1 타입 변환이란?\t<BR>\n9.2 암묵적 타입 변환\t<BR>\n____9.2.1 문자열 타입으로 변환\t<BR>\n____9.2.2 숫자 타입으로 변환\t<BR>\n____9.2.3 불리언 타입으로 변환\t<BR>\n9.3 명시적 타입 변환\t<BR>\n____9.3.1 문자열 타입으로 변환\t<BR>\n____9.3.2 숫자 타입으로 변환\t<BR>\n____9.3.3 불리언 타입으로 변환\t<BR>\n9.4 단축 평가\t<BR>\n____9.4.1 논리 연산자를 사용한 단축 평가\t<BR>\n____9.4.2 옵셔널 체이닝 연산자\t<BR>\n____9.4.3 null 병합 연산자<BR>\n<BR>\n▣ 10장: 객체 리터럴\t<BR>\n10.1 객체란?\t<BR>\n10.2 객체 리터럴에 의한 객체 생성\t<BR>\n10.3 프로퍼티\t<BR>\n10.4 메서드\t<BR>\n10.5 프로퍼티 접근\t<BR>\n10.6 프로퍼티 값 갱신\t<BR>\n10.7 프로퍼티 동적 생성\t<BR>\n10.8 프로퍼티 삭제\t<BR>\n10.9 ES6에서 추가된 객체 리터럴의 확장 기능\t<BR>\n____10.9.1 프로퍼티 축약 표현\t<BR>\n____10.9.2 계산된 프로퍼티 이름\t<BR>\n____10.9.3 메서드 축약 표현\t<BR>\n<BR>\n▣ 11장: 원시 값과 객체의 비교<BR>\n11.1 원시 값\t<BR>\n____11.1.1 변경 불가능한 값\t<BR>\n____11.1.2 문자열과 불변성\t<BR>\n____11.1.3 값에 의한 전달\t<BR>\n11.2 객체\t<BR>\n____11.2.1 변경 가능한 값\t<BR>\n____11.2.2 참조에 의한 전달<BR>\n<BR>\n▣ 12장: 함수\t<BR>\n12.1 함수란?\t<BR>\n12.2 함수를 사용하는 이유\t<BR>\n12.3 함수 리터럴\t<BR>\n12.4 함수 정의\t<BR>\n____12.4.1 함수 선언문\t<BR>\n____12.4.2 함수 표현식\t<BR>\n____12.4.3 함수 생성 시점과 함수 호이스팅\t<BR>\n____12.4.4 Function 생성자 함수\t<BR>\n____12.4.5 화살표 함수\t<BR>\n12.5 함수 호출\t<BR>\n____12.5.1 매개변수와 인수\t<BR>\n____12.5.2 인수 확인\t<BR>\n____12.5.3 매개변수의 최대 개수\t<BR>\n____12.5.4 반환문\t<BR>\n12.6 참조에 의한 전달과 외부 상태의 변경\t<BR>\n12.7 다양한 함수의 형태\t<BR>\n____12.7.1 즉시 실행 함수\t<BR>\n____12.7.2 재귀 함수\t<BR>\n____12.7.3 중첩 함수\t<BR>\n____12.7.4 콜백 함수\t<BR>\n____12.7.5 순수 함수와 비순수 함수<BR>\n<BR>\n▣ 13장: 스코프\t<BR>\n13.1 스코프란?\t<BR>\n13.2 스코프의 종류\t<BR>\n____13.2.1 전역과 전역 스코프\t<BR>\n____13.2.2 지역과 지역 스코프\t<BR>\n13.3 스코프 체인 \t<BR>\n____13.3.1 스코프 체인에 의한 변수 검색\t<BR>\n____13.3.2 스코프 체인에 의한 함수 검색\t<BR>\n13.4 함수 레벨 스코프\t<BR>\n13.5 렉시컬 스코프\t<BR>\n<BR>\n▣ 14장: 전역 변수의 문제점<BR>\n14.1 변수의 생명 주기\t<BR>\n____14.1.1 지역 변수의 생명 주기\t<BR>\n____14.1.2 전역 변수의 생명 주기\t<BR>\n14.2 전역 변수의 문제점\t<BR>\n14.3 전역 변수의 사용을 억제하는 방법\t<BR>\n____14.3.1 즉시 실행 함수\t<BR>\n____14.3.2 네임스페이스 객체\t<BR>\n____14.3.3 모듈 패턴\t<BR>\n____14.3.4 ES6 모듈<BR>\n<BR>\n▣ 15장: let, const 키워드와 블록 레벨 스코프\t<BR>\n15.1 var 키워드로 선언한 변수의 문제점\t<BR>\n____15.1.1 변수 중복 선언 허용\t<BR>\n____15.1.2 함수 레벨 스코프\t<BR>\n____15.1.3 변수 호이스팅\t<BR>\n15.2 let 키워드\t<BR>\n____15.2.1 변수 중복 선언 금지\t<BR>\n____15.2.2 블록 레벨 스코프\t<BR>\n____15.2.3 변수 호이스팅\t<BR>\n____15.2.4 전역 객체와 let\t<BR>\n15.3 const 키워드\t<BR>\n____15.3.1 선언과 초기화\t<BR>\n____15.3.2 재할당 금지\t<BR>\n____15.3.3 상수\t<BR>\n____15.3.4 const 키워드와 객체\t<BR>\n15.4 var vs. let vs. const\t<BR>\n<BR>\n▣ 16장: 프로퍼티 어트리뷰트<BR>\n16.1 내부 슬롯과 내부 메서드\t<BR>\n16.2 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체\t<BR>\n16.3 데이터 프로퍼티와 접근자 프로퍼티 \t<BR>\n____16.3.1 데이터 프로퍼티\t<BR>\n____16.3.2 접근자 프로퍼티\t<BR>\n16.4 프로퍼티 정의\t<BR>\n16.5 객체 변경 방지\t<BR>\n____16.5.1 객체 확장 금지\t<BR>\n____16.5.2 객체 밀봉\t<BR>\n____16.5.3 객체 동결\t<BR>\n____16.5.4 불변 객체\t<BR>\n<BR>\n▣ 17장: 생성자 함수에 의한 객체 생성<BR>\n17.1 Object 생성자 함수\t<BR>\n17.2 생성자 함수\t<BR>\n____17.2.1 객체 리터럴에 의한 객체 생성 방식의 문제점\t<BR>\n____17.2.2 생성자 함수에 의한 객체 생성 방식의 장점\t<BR>\n____17.2.3 생성자 함수의 인스턴스 생성 과정\t<BR>\n____17.2.4 내부 메서드 [[Call]]과 [[Construct]]\t<BR>\n____17.2.5 constructor와 non-constructor의 구분\t<BR>\n____17.2.6 new 연산자\t<BR>\n____17.2.7 new.target\t<BR>\n<BR>\n▣ 18장: 함수와 일급 객체<BR>\n18.1 일급 객체\t<BR>\n18.2 함수 객체의 프로퍼티\t<BR>\n____18.2.1 arguments 프로퍼티\t<BR>\n____18.2.2 caller 프로퍼티\t<BR>\n____18.2.3 length 프로퍼티\t<BR>\n____18.2.4 name 프로퍼티\t<BR>\n____18.2.5 __proto__ 접근자 프로퍼티\t<BR>\n____18.2.6 prototype 프로퍼티\t<BR>\n<BR>\n▣ 19장: 프로토타입<BR>\n19.1 객체지향 프로그래밍\t<BR>\n19.2 상속과 프로토타입\t<BR>\n19.3 프로토타입 객체\t<BR>\n____19.3.1 __proto__ 접근자 프로퍼티\t<BR>\n____19.3.2 함수 객체의 prototype 프로퍼티\t<BR>\n____19.3.3 프로토타입의 constructor 프로퍼티와 생성자 함수\t<BR>\n19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입\t<BR>\n19.5 프로토타입의 생성 시점\t<BR>\n____19.5.1 사용자 정의 생성자 함수와 프로토타입 생성 시점\t<BR>\n____19.5.2 빌트인 생성자 함수와 프로토타입 생성 시점\t<BR>\n19.6 객체 생성 방식과 프로토타입의 결정\t<BR>\n____19.6.1 객체 리터럴에 의해 생성된 객체의 프로토타입\t<BR>\n____19.6.2 Object 생성자 함수에 의해 생성된 객체의 프로토타입\t<BR>\n____19.6.3 생성자 함수에 의해 생성된 객체의 프로토타입\t<BR>\n19.7 프로토타입 체인\t<BR>\n19.8 오버라이딩과 프로퍼티 섀도잉\t<BR>\n19.9 프로토타입의 교체\t<BR>\n____19.9.1 생성자 함수에 의한 프로토타입의 교체\t<BR>\n____19.9.2 인스턴스에 의한 프로토타입의 교체\t<BR>\n19.10 instanceof 연산자\t<BR>\n19.11 직접 상속\t<BR>\n____19.11.1 Object.create에 의한 직접 상속\t<BR>\n____19.11.2 객체 리터럴 내부에서 __proto__에 의한 직접 상속\t<BR>\n19.12 정적 프로퍼티/메서드\t<BR>\n19.13 프로퍼티 존재 확인\t<BR>\n____19.13.1 in 연산자\t<BR>\n____19.13.2 Object.prototype.hasOwnProperty 메서드\t<BR>\n19.14 프로퍼티 열거\t<BR>\n____19.14.1 for...in 문\t<BR>\n____19.14.2 Object.keys/values/entries 메서드\t<BR>\n<BR>\n▣ 20장: strict mode<BR>\n20.1 strict mode란?\t<BR>\n20.2 strict mode의 적용\t<BR>\n20.3 전역에 strict mode를 적용하는 것은 피하자\t<BR>\n20.4 함수 단위로 strict mode를 적용하는 것도 피하자\t<BR>\n20.5 strict mode가 발생시키는 에러\t<BR>\n____20.5.1 암묵적 전역\t<BR>\n____20.5.2 변수, 함수, 매개변수의 삭제\t<BR>\n____20.5.3 매개변수 이름의 중복\t<BR>\n____20.5.4 with 문의 사용\t<BR>\n20.6 strict mode 적용에 의한 변화\t<BR>\n____20.6.1 일반 함수의 this\t<BR>\n____20.6.2 arguments 객체<BR>\n<BR>\n▣ 21장: 빌트인 객체\t<BR>\n21.1 자바스크립트 객체의 분류\t<BR>\n21.2 표준 빌트인 객체\t<BR>\n21.3 원시값과 래퍼 객체\t<BR>\n21.4 전역 객체\t<BR>\n____21.4.1 빌트인 전역 프로퍼티\t<BR>\n____21.4.2 빌트인 전역 함수\t<BR>\n____21.4.3 암묵적 전역 \t<BR>\n<BR>\n▣ 22장: this<BR>\n22.1 this 키워드\t<BR>\n22.2 함수 호출 방식과 this 바인딩\t<BR>\n____22.2.1 일반 함수 호출\t<BR>\n____22.2.2 메서드 호출\t<BR>\n____22.2.3 생성자 함수 호출\t<BR>\n____22.2.4 Function.prototype.apply/call/bind 메서드에 의한 간접 호출\t<BR>\n<BR>\n▣ 23장: 실행 컨텍스트<BR>\n23.1 소스코드의 타입\t<BR>\n23.2 소스코드의 평가와 실행\t<BR>\n23.3 실행 컨텍스트의 역할\t<BR>\n23.4 실행 컨텍스트 스택\t<BR>\n23.5 렉시컬 환경\t<BR>\n23.6 실행 컨텍스트의 생성과 식별자 검색 과정\t<BR>\n____23.6.1 전역 객체 생성\t<BR>\n____23.6.2 전역 코드 평가<BR>\n____24.6.3 전역 코드 실행\t<BR>\n____24.6.4 foo 함수 코드 평가 \t<BR>\n____23.6.5 foo 함수 코드 실행\t<BR>\n____23.6.6 bar 함수 코드 평가 \t<BR>\n____23.6.7 bar 함수 코드 실행\t<BR>\n____23.6.8 bar 함수 코드 실행 종료\t<BR>\n____23.6.9 foo 함수 코드 실행 종료\t<BR>\n____23.6.10 전역 코드 실행 종료\t<BR>\n23.7 실행 컨텍스트와 블록 레벨 스코프\t<BR>\n<BR>\n▣ 24장: 클로저<BR>\n24.1 렉시컬 스코프\t<BR>\n24.2 함수 객체의 내부 슬롯 [[Environment]]\t<BR>\n24.3 클로저와 렉시컬 환경\t<BR>\n24.4 클로저의 활용\t<BR>\n24.5 캡슐화와 정보 은닉\t<BR>\n24.6 자주 발생하는 실수\t<BR>\n<BR>\n▣ 25장: 클래스<BR>\n25.1 클래스는 프로토타입의 문법적 설탕인가?\t<BR>\n25.2 클래스 정의\t<BR>\n25.3 클래스 호이스팅\t<BR>\n25.4 인스턴스 생성\t<BR>\n25.5 메서드\t<BR>\n____25.5.1 constructor\t<BR>\n____25.5.2 프로토타입 메서드\t<BR>\n____25.5.3 정적 메서드\t<BR>\n____25.5.4 정적 메서드와 프로토타입 메서드의 차이\t<BR>\n____25.5.5 클래스에서 정의한 메서드의 특징\t<BR>\n25.6 클래스의 인스턴스 생성 과정\t<BR>\n25.7 프로퍼티\t<BR>\n____25.7.1 인스턴스 프로퍼티\t<BR>\n____25.7.2 접근자 프로퍼티\t<BR>\n____25.7.3 클래스 필드 정의 제안\t<BR>\n____25.7.4 private 필드 정의 제안\t<BR>\n____25.7.5 static 필드 정의 제안\t<BR>\n25.8 상속에 의한 클래스 확장\t<BR>\n____25.8.1 클래스 상속과 생성자 함수 상속\t<BR>\n____25.8.2 extends 키워드\t<BR>\n____25.8.3 동적 상속\t<BR>\n____25.8.4 서브클래스의 constructor\t<BR>\n____25.8.5 super 키워드\t<BR>\n____25.8.6 상속 클래스의 인스턴스 생성 과정\t<BR>\n____25.8.7 표준 빌트인 생성자 함수 확장\t<BR>\n<BR>\n▣ 26장: ES6 함수의 추가 기능<BR>\n26.1 함수의 구분\t<BR>\n26.2 메서드\t<BR>\n26.3 화살표 함수\t<BR>\n____26.3.1 화살표 함수 정의\t<BR>\n____26.3.2 화살표 함수와 일반 함수의 차이\t<BR>\n____26.3.3 this\t<BR>\n____26.3.4 super\t<BR>\n____26.3.5 arguments\t<BR>\n26.4 Rest 파라미터\t<BR>\n____26.4.1 기본 문법\t<BR>\n____26.4.2 Rest 파라미터와 arguments 객체\t<BR>\n26.5 매개변수 기본값\t<BR>\n<BR>\n▣ 27장: 배열<BR>\n27.1 배열이란?\t<BR>\n27.2 자바스크립트 배열은 배열이 아니다\t<BR>\n27.3 length 프로퍼티와 희소 배열\t<BR>\n27.4 배열 생성\t<BR>\n____27.4.1 배열 리터럴\t<BR>\n____27.4.2 Array 생성자 함수\t<BR>\n____27.4.3 Array.of\t<BR>\n____27.4.4 Array.from\t<BR>\n27.5 배열 요소의 참조\t<BR>\n27.6 배열 요소의 추가와 갱신\t<BR>\n27.7 배열 요소의 삭제\t<BR>\n27.8 배열 메서드\t<BR>\n____27.8.1 Array.isArray\t<BR>\n____27.8.2 Array.prototype.indexOf\t<BR>\n____27.8.3 Array.prototype.push\t<BR>\n____27.8.4 Array.prototype.pop\t<BR>\n____27.8.5 Array.prototype.unshift\t<BR>\n____27.8.6 Array.prototype.shift\t<BR>\n____27.8.7 Array.prototype.concat\t<BR>\n____27.8.8 Array.prototype.splice\t<BR>\n____27.8.9 Array.prototype.slice\t<BR>\n____27.8.10 Array.prototype.join\t<BR>\n____27.8.11 Array.prototype.reverse\t<BR>\n____27.8.12 Array.prototype.fill\t<BR>\n____27.8.13 Array.prototype.includes\t<BR>\n____27.8.14 Array.prototype.flat\t<BR>\n27.9 배열 고차 함수\t<BR>\n____27.9.1 Array.prototype.sort\t<BR>\n____27.9.2 Array.prototype.forEach\t<BR>\n____27.9.3 Array.prototype.map\t<BR>\n____27.9.4 Array.prototype.filter\t<BR>\n____27.9.5 Array.prototype.reduce\t<BR>\n____27.9.6 Array.prototype.some\t<BR>\n____27.9.7 Array.prototype.every\t<BR>\n____27.9.8 Array.prototype.find\t<BR>\n____27.9.9 Array.prototype.findIndex\t<BR>\n____27.9.10 Array.prototype.flatMap<BR>\n<BR>\n▣ 28장: Number\t<BR>\n28.1 Number 생성자 함수\t<BR>\n28.2 Number 프로퍼티\t<BR>\n____28.2.1 Number.EPSILON\t<BR>\n____28.2.2 Number.MAX_VALUE\t<BR>\n____28.2.3 Number.MIN_VALUE\t<BR>\n____28.2.4 Number.MAX_SAFE_INTEGER\t<BR>\n____28.2.5 Number.MIN_SAFE_INTEGER\t<BR>\n____28.2.6 Number.POSITIVE_INFINITY\t<BR>\n____28.2.7 Number.NEGATIVE_INFINITY\t<BR>\n____28.2.8 Number.NaN\t<BR>\n28.3 Number 메서드\t<BR>\n____28.3.1 Number.isFinite\t<BR>\n____28.3.2 Number.isInteger\t<BR>\n____28.3.3 Number.isNaN\t<BR>\n____28.3.4 Number.isSafeInteger\t<BR>\n____28.3.5 Number.prototype.toExponential\t<BR>\n____28.3.6 Number.prototype.toFixed\t<BR>\n____28.3.7 Number.prototype.toPrecision\t<BR>\n____28.3.8 Number.prototype.toString\t<BR>\n<BR>\n▣ 29장: Math<BR>\n29.1 Math 프로퍼티\t<BR>\n____29.1.1 Math.PI\t<BR>\n29.2 Math 메서드\t<BR>\n____29.2.1 Math.abs\t<BR>\n____29.2.2 Math.round\t<BR>\n____29.2.3 Math.ceil\t<BR>\n____29.2.4 Math.floor\t<BR>\n____29.2.5 Math.sqrt\t<BR>\n____29.2.6 Math.random\t<BR>\n____29.2.7 Math.pow\t<BR>\n____29.2.8 Math.max\t<BR>\n____29.2.9 Math.min<BR>\n<BR>\n▣ 30장: Date\t<BR>\n30.1 Date 생성자 함수\t<BR>\n____30.1.1 new Date()\t<BR>\n____30.1.2 new Date(milliseconds)\t<BR>\n____30.1.3 new Date(dateString)\t<BR>\n____30.1.4 new Date(year, month, day, hour, minute, second, millisecond])\t<BR>\n30.2 Date 메서드\t<BR>\n____30.2.1 Date.now\t<BR>\n____30.2.2 Date.parse\t<BR>\n____30.2.3 Date.UTC\t<BR>\n____30.2.4 Date.prototype.getFullYear\t<BR>\n____30.2.5 Date.prototype.setFullYear\t<BR>\n____30.2.6 Date.prototype.getMonth\t<BR>\n____30.2.7 Date.prototype.setMonth\t<BR>\n____30.2.8 Date.prototype.getDate\t<BR>\n____30.2.9 Date.prototype.setDate\t<BR>\n____30.2.10 Date.prototype.getDay\t<BR>\n____30.2.11 Date.prototype.getHours\t<BR>\n____30.2.12 Date.prototype.setHours\t<BR>\n____30.2.13 Date.prototype.getMinutes\t<BR>\n____30.2.14 Date.prototype.setMinutes\t<BR>\n____30.2.15 Date.prototype.getSeconds\t<BR>\n____30.2.16 Date.prototype.setSeconds\t<BR>\n____30.2.17 Date.prototype.getMilliseconds\t<BR>\n____30.2.18 Date.prototype.setMilliseconds\t<BR>\n____30.2.19 Date.prototype.getTime\t<BR>\n____30.2.20 Date.prototype.setTime\t<BR>\n____30.2.21 Date.prototype.getTimezoneOffset\t<BR>\n____30.2.22 Date.prototype.toDateString\t<BR>\n____30.2.23 Date.prototype.toTimeString\t<BR>\n____30.2.24 Date.prototype.toISOString\t<BR>\n____30.2.25 Date.prototype.toLocaleString\t<BR>\n____30.2.26 Date.prototype.toLocaleTimeString\t<BR>\n30.3 Date를 활용한 시계 예제<BR>\n<BR>\n▣ 31장: RegExp\t<BR>\n31.1 정규 표현식이란?\t<BR>\n31.2 정규 표현식의 생성\t<BR>\n31.3 RegExp 메서드\t<BR>\n____31.3.1 RegExp.prototype.exec\t<BR>\n____31.3.2 RegExp.prototype.test\t<BR>\n____31.3.3 String.prototype.match\t<BR>\n31.4 플래그\t<BR>\n31.5 패턴\t<BR>\n____31.5.1 문자열 검색\t<BR>\n____31.5.2 임의의 문자열 검색\t<BR>\n____31.5.3 반복 검색\t<BR>\n____31.5.4 OR 검색\t<BR>\n____31.5.5 NOT 검색\t<BR>\n____31.5.6 시작 위치로 검색\t<BR>\n____31.5.7 마지막 위치로 검색\t<BR>\n31.6 자주 사용하는 정규표현식\t<BR>\n____31.6.1 특정 단어로 시작하는지 검사\t<BR>\n____31.6.2 특정 단어로 끝나는지 검사\t<BR>\n____31.6.3 숫자로만 이루어진 문자열인지 검사\t<BR>\n____31.6.4 하나 이상의 공백으로 시작하는지 검사\t<BR>\n____31.6.5 아이디로 사용 가능한지 검사\t<BR>\n____31.6.6 메일 주소 형식에 맞는지 검사\t<BR>\n____31.6.7 핸드폰 번호 형식에 맞는지 검사\t<BR>\n____31.6.8 특수 문자 포함 여부 검사<BR>\n<BR>\n▣ 32장: String\t<BR>\n32.1 String 생성자 함수\t<BR>\n32.2 length 프로퍼티\t<BR>\n32.3 String 메서드\t<BR>\n____32.3.1 String.prototype.indexOf\t<BR>\n____32.3.2 String.prototype.search\t<BR>\n____32.3.3 String.prototype.includes\t<BR>\n____32.3.4 String.prototype.startsWith\t<BR>\n____32.3.5 String.prototype.endsWith\t<BR>\n____32.3.6 String.prototype.charAt\t<BR>\n____32.3.7 String.prototype.substring\t<BR>\n____32.3.8 String.prototype.slice\t<BR>\n____32.3.9 String.prototype.toUpperCase\t<BR>\n____32.3.10 String.prototype.toLowerCase\t<BR>\n____32.3.11 String.prototype.trim\t<BR>\n____32.3.12 String.prototype.repeat\t<BR>\n____32.3.13 String.prototype.replace\t<BR>\n____32.3.14 String.prototype.split<BR>\n<BR>\n▣ 33장: 7번째 데이터 타입 Symbol\t<BR>\n33.1 심벌이란?\t<BR>\n33.2 심벌 값의 생성\t<BR>\n____33.2.1 Symbol 함수\t<BR>\n____33.2.2 Symbol.for / Symbol.keyFor 메서드\t<BR>\n33.3 심벌과 상수\t<BR>\n33.4 심벌과 프로퍼티 키\t<BR>\n33.5 심벌과 프로퍼티 은닉\t<BR>\n33.6 심벌과 표준 빌트인 객체 확장\t<BR>\n33.7 Well-known Symbol\t<BR>\n<BR>\n▣ 34장: 이터러블<BR>\n34.1 이터레이션 프로토콜\t<BR>\n____34.1.1 이터러블\t<BR>\n____34.1.2 이터레이터\t<BR>\n34.2 빌트인 이터러블\t<BR>\n34.3 for...of 문\t<BR>\n34.4 이터러블과 유사 배열 객체\t<BR>\n34.5 이터레이션 프로토콜의 필요성\t<BR>\n34.6 사용자 정의 이터러블\t<BR>\n____34.6.1 사용자 정의 이터러블 구현\t<BR>\n____34.6.2 이터러블을 생성하는 함수\t<BR>\n____34.6.3 이터러블이면서 이터레이터인 객체를 생성하는 함수\t<BR>\n____34.6.4 무한 이터러블과 지연 평가\t<BR>\n<BR>\n▣ 35장: 스프레드 문법<BR>\n35.1 함수 호출문의 인수 목록에서 사용하는 경우\t<BR>\n35.2 배열 리터럴 내부에서 사용하는 경우\t<BR>\n____35.2.1 concat\t<BR>\n____35.2.2 splice\t<BR>\n____35.2.3 배열 복사\t<BR>\n____35.2.4 이터러블을 배열로 변환\t<BR>\n35.3 객체 리터럴 내부에서 사용하는 경우\t<BR>\n<BR>\n▣ 36장: 디스트럭처링 할당<BR>\n36.1 배열 디스트럭처링 할당\t<BR>\n36.2 객체 디스트럭처링 할당\t<BR>\n<BR>\n▣ 37장: Set과 Map<BR>\n37.1 Set\t<BR>\n____37.1.1 Set 객체의 생성\t<BR>\n____37.1.2 요소 개수 확인\t<BR>\n____37.1.3 요소 추가\t<BR>\n____37.1.4 요소 존재 여부 확인\t<BR>\n____37.1.5 요소 삭제\t<BR>\n____37.1.6 요소 일괄 삭제\t<BR>\n____37.1.7 요소 순회\t<BR>\n____37.1.8 집합 연산\t<BR>\n37.2 Map\t<BR>\n____37.2.1 Map 객체의 생성\t<BR>\n____37.2.2 요소 개수 확인\t<BR>\n____37.2.3 요소 추가\t<BR>\n____37.2.4 요소 취득\t<BR>\n____37.2.5 요소 존재 여부 확인\t<BR>\n____37.2.6 요소 삭제\t<BR>\n____37.2.7 요소 일괄 삭제\t<BR>\n____37.2.8 요소 순회\t<BR>\n<BR>\n▣ 38장: 브라우저의 렌더링 과정<BR>\n38.1 요청과 응답\t<BR>\n38.2 HTTP 1.1과 HTTP 2.0\t<BR>\n38.3 HTML 파싱과 DOM 생성\t<BR>\n38.4 CSS 파싱과 CSSOM 생성\t<BR>\n38.5 렌더 트리 생성\t<BR>\n38.6 자바스크립트 파싱과 실행\t<BR>\n38.7 리플로우와 리페인트\t<BR>\n38.8 자바스크립트 파싱에 의한 HTML 파싱 중단\t<BR>\n38.9 script 태그의 async/defer 어트리뷰트\t<BR>\n<BR>\n▣ 39장: DOM<BR>\n39.1 노드\t<BR>\n____39.1.1 HTML 요소와 노드 객체\t<BR>\n____39.1.2 노드 객체의 타입\t<BR>\n____39.1.3 노드 객체의 상속 구조\t<BR>\n39.2 요소 노드 취득\t<BR>\n____39.2.1 id를 이용한 요소 노드 취득\t<BR>\n____39.2.2 태그 이름을 이용한 요소 노드 취득\t<BR>\n____39.2.3 class를 이용한 요소 노드 취득\t<BR>\n____39.2.4 CSS 선택자를 이용한 요소 노드 취득\t<BR>\n____39.2.5 특정 요소 노드를 취득할 수 있는지 확인\t<BR>\n____39.2.6 HTMLCollection과 NodeList\t<BR>\n39.3 노드 탐색\t<BR>\n____39.3.1 공백 텍스트 노드\t<BR>\n____39.3.2 자식 노드 탐색\t<BR>\n____39.3.3 자식 노드 존재 확인\t<BR>\n____39.3.4 요소 노드의 텍스트 노드 탐색\t<BR>\n____39.3.5 부모 노드 탐색\t<BR>\n____39.3.6 형제 노드 탐색\t<BR>\n39.4 노드 정보 취득\t<BR>\n39.5 요소 노드의 텍스트 조작\t<BR>\n____39.5.1 nodeValue\t<BR>\n____39.5.2 textContent\t<BR>\n39.6 DOM 조작\t<BR>\n____39.6.1 innerHTML\t<BR>\n____39.6.2 insertAdjacentHTML 메서드\t<BR>\n____39.6.3 노드 생성과 추가\t<BR>\n____39.6.4 복수의 노드 생성과 추가\t<BR>\n____39.6.5 노드 삽입\t<BR>\n____39.6.6 노드 이동\t<BR>\n____39.6.7 노드 복사\t<BR>\n____39.6.8 노드 교체\t<BR>\n____39.6.9 노드 삭제\t<BR>\n39.7 어트리뷰트\t<BR>\n____39.7.1 어트리뷰트 노드와 attributes 프로퍼티\t<BR>\n____39.7.2 HTML 어트리뷰트 조작 \t<BR>\n____39.7.3 HTML 어트리뷰트 vs. DOM 프로퍼티\t<BR>\n____39.7.4 data 어트리뷰트와 dataset 프로퍼티\t<BR>\n39.8 스타일\t<BR>\n____39.8.1 인라인 스타일 조작\t<BR>\n____39.8.2 클래스 조작\t<BR>\n____39.8.3 요소에 적용되어 있는 CSS 스타일 참조\t<BR>\n39.9 DOM 표준<BR>\n<BR>\n▣ 40장: 이벤트\t<BR>\n40.1 이벤트 드리븐 프로그래밍\t<BR>\n40.2 이벤트 타입\t<BR>\n____40.2.1 마우스 이벤트\t<BR>\n____40.2.2 키보드 이벤트\t<BR>\n____40.2.3 포커스 이벤트\t<BR>\n____40.2.4 폼 이벤트\t<BR>\n____40.2.5 값 변경 이벤트\t<BR>\n____40.2.6 DOM 뮤테이션 이벤트\t<BR>\n____40.2.7 뷰 이벤트\t<BR>\n____40.2.8 리소스 이벤트\t<BR>\n40.3 이벤트 핸들러 등록\t<BR>\n____40.3.1 이벤트 핸들러 어트리뷰트 방식\t<BR>\n____40.3.2 이벤트 핸들러 프로퍼티 방식\t<BR>\n____40.3.3 addEventListener 메서드 방식\t<BR>\n40.4 이벤트 핸들러 제거\t<BR>\n40.5 이벤트 객체\t<BR>\n____40.5.1 이벤트 객체의 상속 구조\t<BR>\n____40.5.2 이벤트 객체의 공통 프로퍼티\t<BR>\n____40.5.3 마우스 정보 취득\t<BR>\n____40.5.4 키보드 정보 취득\t<BR>\n40.6 이벤트 전파\t<BR>\n40.7 이벤트 위임\t<BR>\n40.8 DOM 요소의 기본 동작의 조작\t<BR>\n____40.8.1 DOM 요소의 기본 동작 중단\t<BR>\n____40.8.2 이벤트 전파 방지\t<BR>\n40.9 이벤트 핸들러 내부의 this\t<BR>\n____40.9.1 이벤트 핸들러 어트리뷰트 방식\t<BR>\n____40.9.2 이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식\t<BR>\n40.10 이벤트 핸들러에 인수 전달\t<BR>\n40.11 커스텀 이벤트\t<BR>\n____40.11.1 커스텀 이벤트 생성\t<BR>\n____40.11.2 커스텀 이벤트 디스패치<BR>\n<BR>\n▣ 41장: 타이머\t<BR>\n41.1 호출 스케줄링\t<BR>\n41.2 타이머 함수\t<BR>\n____41.2.1 setTimeout / clearTimeout\t<BR>\n____41.2.2 setInterval / clearInterval\t<BR>\n41.3 디바운스와 스로틀\t<BR>\n____41.3.1 디바운스\t<BR>\n____41.3.2 스로틀<BR>\n<BR>\n▣ 42장: 비동기 프로그래밍\t<BR>\n42.1 동기 처리와 비동기 처리\t<BR>\n42.2 이벤트 루프와 태스크 큐\t<BR>\n<BR>\n▣ 43장: Ajax<BR>\n43.1 Ajax란?\t<BR>\n43.2 JSON\t<BR>\n____43.2.1 JSON 표기 방식\t<BR>\n____43.2.2 JSON.stringify\t<BR>\n____43.2.3 JSON.parse\t<BR>\n43.3 XMLHttpRequest\t<BR>\n____43.3.1 XMLHttpRequest 객체 생성\t<BR>\n____43.3.2 XMLHttpRequest 객체의 프로퍼티와 메서드\t<BR>\n____43.3.3 HTTP 요청 전송\t<BR>\n____43.3.4 HTTP 응답 처리\t<BR>\n<BR>\n▣ 44장: REST API<BR>\n44.1 REST API의 구성\t<BR>\n44.2 REST API 설계 원칙\t<BR>\n44.3 JSON Server를 이용한 REST API 실습\t<BR>\n____44.3.1 JSON Server 설치\t<BR>\n____44.3.2 db.json 파일 생성\t<BR>\n____44.3.3 JSON Server 실행\t<BR>\n____44.3.4 GET 요청\t<BR>\n____44.3.5 POST 요청\t<BR>\n____44.3.6 PUT 요청\t<BR>\n____44.3.7 PATCH 요청\t<BR>\n____44.3.8 DELETE 요청\t<BR>\n<BR>\n▣ 45장: 프로미스<BR>\n45.1 비동기 처리를 위한 콜백 패턴의 단점\t<BR>\n____45.1.1 콜백 헬\t<BR>\n____45.1.2 에러 처리의 한계\t<BR>\n45.2 프로미스의 생성\t<BR>\n45.3 프로미스의 후속 처리 메서드\t<BR>\n____45.3.1 Promise.prototype.then\t<BR>\n____45.3.2 Promise.prototype.catch\t<BR>\n____45.3.3 Promise.prototype.finally\t<BR>\n45.4 프로미스의 에러 처리\t<BR>\n45.5 프로미스 체이닝\t<BR>\n45.6 프로미스의 정적 메서드\t<BR>\n____45.6.1 Promise.resolve / Promise.reject\t<BR>\n____45.6.2 Promise.all\t<BR>\n____45.6.3 Promise.race\t<BR>\n____45.6.4 Promise.allSettled\t<BR>\n45.7 마이크로태스크 큐\t<BR>\n45.8 fetch\t<BR>\n<BR>\n▣ 46장: 제너레이터와 async/await<BR>\n46.1 제너레이터란?\t<BR>\n46.2 제너레이터 함수의 정의\t<BR>\n46.3 제너레이터 객체\t<BR>\n46.4 제너레이터의 일시 중지와 재개\t<BR>\n46.5 제너레이터의 활용\t<BR>\n____46.5.1 이터러블의 구현\t<BR>\n____46.5.2 비동기 처리\t<BR>\n46.6 async/await\t<BR>\n____46.6.1 async 함수\t<BR>\n____46.6.2 await 키워드\t<BR>\n____46.6.3 에러 처리\t<BR>\n<BR>\n▣ 47장: 에러 처리<BR>\n47.1 에러 처리의 필요성\t<BR>\n47.2 try...catch...finally 문\t<BR>\n47.3 Error 객체\t<BR>\n47.4 throw 문\t<BR>\n47.5 에러의 전파\t<BR>\n<BR>\n▣ 48장: 모듈<BR>\n48.1 모듈의 일반적 의미\t<BR>\n48.2 자바스크립트와 모듈\t<BR>\n48.3 ES6 모듈(ESM)\t<BR>\n____48.3.1 모듈 스코프\t<BR>\n____48.3.2 export 키워드\t<BR>\n____48.3.3 import 키워드<BR>\n<BR>\n▣ 49장: Babel과 Webpack을 이용한 ES6+/ES.NEXT 개발 환경 구축\t<BR>\n49.1 Babel\t<BR>\n____49.1.1 Babel 설치\t<BR>\n____49.1.2 Babel 프리셋 설치와 babel.config.json 설정 파일 작성\t<BR>\n____49.1.3 트랜스파일링\t<BR>\n____49.1.4 Babel 플러그인 설치\t<BR>\n____49.1.5 브라우저에서 모듈 로딩 테스트\t<BR>\n49.2 Webpack\t<BR>\n____49.2.1 Webpack 설치\t<BR>\n____49.2.2 babel-loader 설치\t<BR>\n____49.2.3 webpack.config.js 설정 파일 작성\t<BR>\n____49.2.4 babel-polyfill 설치\t</p>",
        "letslookimg": [
          "https://image.aladin.co.kr/product/25155/25/letslook/K282633473_fs.jpg",
          "https://image.aladin.co.kr/product/25155/25/letslook/K282633473_bs.jpg",
          "https://image.aladin.co.kr/product/25155/25/letslook/K282633473_t1s.jpg"
        ],
        "authors": [
          {
            "authorType": "author",
            "authorid": 6329332,
            "desc": "지은이",
            "name": "이웅모"
          }
        ],
        "ebookList": [
          {
            "itemId": 260060498,
            "isbn": "E252538362",
            "priceSales": 31500,
            "link": "https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=260060498"
          }
        ]
      }
    }
  ]
}
